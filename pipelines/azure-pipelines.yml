# Azure DevOps CI/CD Pipeline for Claim Status API
# Builds container image, performs security scanning, and deploys to Azure Container Apps

trigger:
  branches:
    include:
    - master    # ✅ Correct for your GitHub default branch
    - develop
  paths:
    include:
    - src/*
    - mocks/*
    - Dockerfile
    - pipelines/azure-pipelines.yml

variables:
  # Build variables - Update these to match your actual setup
  dockerRegistryServiceConnection: 'acr-connection'
  containerRegistry: 'claimsacrcna.azurecr.io'  # ✅ Matches your existing ACR
  imageRepository: 'claim-status-api'
  dockerfilePath: '$(Build.SourcesDirectory)/Dockerfile'
  tag: '$(Build.BuildId)'
  
  # Azure resources - Update these to match your actual deployment
  resourceGroupName: 'claims-api-lab-rg'  # ✅ Matches your RG name
  bicepPrefix: 'claims'
  bicepEnvironment: 'dev'
  deploymentName: 'claims-deploy-$(Build.BuildId)'

  # Security scanning
  trivyVersion: '0.44.0'

stages:
- stage: Build
  displayName: 'Build and Push Image'
  jobs:
  - job: Build
    displayName: 'Build Docker Image'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: Docker@2
      displayName: 'Build Docker Image'
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        repository: '$(imageRepository)'
        command: 'build'
        Dockerfile: '$(dockerfilePath)'
        tags: |
          $(tag)
          latest
        arguments: '--build-arg BUILD_DATE="$(date -u +"%Y-%m-%dT%H:%M:%SZ")" --build-arg BUILD_VERSION="$(Build.BuildId)"'

    - task: Docker@2
      displayName: 'Push Image to ACR'
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        repository: '$(imageRepository)'
        command: 'push'
        tags: |
          $(tag)
          latest

- stage: SecurityScan
  displayName: 'Security Scanning'
  dependsOn: Build
  jobs:
  - job: ContainerScan
    displayName: 'Container Security Scan'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - script: |
        sudo apt-get update
        sudo apt-get install wget apt-transport-https gnupg lsb-release
        wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
        echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
        sudo apt-get update
        sudo apt-get install trivy
      displayName: 'Install Trivy Scanner'

    - task: AzureCLI@2
      displayName: 'Login to ACR and Scan Image'
      inputs:
        azureSubscription: 'azure-subscription'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Login to ACR
          az acr login --name $(echo $(containerRegistry) | cut -d'.' -f1)
          
          # Pull and scan the image
          docker pull $(containerRegistry)/$(imageRepository):$(tag)
          
          # Run Trivy scan
          trivy image --format json --output trivy-results.json $(containerRegistry)/$(imageRepository):$(tag)
          
          # Check for HIGH and CRITICAL vulnerabilities
          HIGH_COUNT=$(cat trivy-results.json | jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="HIGH")] | length')
          CRITICAL_COUNT=$(cat trivy-results.json | jq '[.Results[]?.Vulnerabilities[]? | select(.Severity=="CRITICAL")] | length')
          
          echo "High vulnerabilities found: $HIGH_COUNT"
          echo "Critical vulnerabilities found: $CRITICAL_COUNT"
          
          # Create summary for scans directory
          mkdir -p $(Build.ArtifactStagingDirectory)/scans
          echo "# Security Scan Results" > $(Build.ArtifactStagingDirectory)/scans/scan-summary.md
          echo "- **Build ID:** $(Build.BuildId)" >> $(Build.ArtifactStagingDirectory)/scans/scan-summary.md
          echo "- **Image:** $(containerRegistry)/$(imageRepository):$(tag)" >> $(Build.ArtifactStagingDirectory)/scans/scan-summary.md
          echo "- **Critical Vulnerabilities:** $CRITICAL_COUNT" >> $(Build.ArtifactStagingDirectory)/scans/scan-summary.md
          echo "- **High Vulnerabilities:** $HIGH_COUNT" >> $(Build.ArtifactStagingDirectory)/scans/scan-summary.md
          echo "- **Scan Date:** $(date)" >> $(Build.ArtifactStagingDirectory)/scans/scan-summary.md
          
          # Copy full results
          cp trivy-results.json $(Build.ArtifactStagingDirectory)/scans/
          
          # Configurable security gate - can be disabled by setting variable
          # Only fail on critical vulnerabilities for master branch
          if [ "$(Build.SourceBranch)" = "refs/heads/master" ] && [ "$CRITICAL_COUNT" -gt 0 ]; then
            echo "##vso[task.logissue type=error]Critical vulnerabilities found on master branch! Failing pipeline."
            exit 1
          elif [ "$CRITICAL_COUNT" -gt 0 ]; then
            echo "##vso[task.logissue type=warning]Critical vulnerabilities found but not on master branch."
          fi
          
          echo "Security scan completed successfully"

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Security Scan Results'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)/scans'
        ArtifactName: 'security-scans'

- stage: Deploy
  displayName: 'Deploy to Azure Container Apps'
  dependsOn: SecurityScan
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))  # Only deploy from master
  variables:
    deploymentTimestamp: $[format('{0:yyyyMMddHHmmss}', pipeline.startTime)]
  jobs:
  - deployment: DeployACA
    displayName: 'Deploy to Container Apps'
    environment: 'production'
    pool:
      vmImage: 'ubuntu-latest'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureCLI@2
            displayName: 'Get Resource Names from Deployment'
            inputs:
              azureSubscription: 'azure-subscription'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Get the most recent successful deployment for this resource group
                LATEST_DEPLOYMENT=$(az deployment group list \
                  -g $(resourceGroupName) \
                  --query "max_by([?properties.provisioningState=='Succeeded'], &properties.timestamp).name" -o tsv)
                
                if [ -z "$LATEST_DEPLOYMENT" ] || [ "$LATEST_DEPLOYMENT" = "null" ]; then
                  echo "##vso[task.logissue type=error]No successful deployments found in resource group $(resourceGroupName)"
                  echo "Please ensure infrastructure has been deployed using the Bicep template first."
                  exit 1
                fi
                
                echo "Using deployment: $LATEST_DEPLOYMENT"
                echo "##vso[task.setvariable variable=actualDeploymentName;isOutput=true]$LATEST_DEPLOYMENT"
                
                # Get resource names from deployment outputs
                CONTAINER_APP_NAME=$(az deployment group show \
                  -g $(resourceGroupName) \
                  -n $LATEST_DEPLOYMENT \
                  --query "properties.outputs.containerAppName.value" -o tsv)
                APIM_NAME=$(az deployment group show \
                  -g $(resourceGroupName) \
                  -n $LATEST_DEPLOYMENT \
                  --query "properties.outputs.apiManagementName.value" -o tsv)
                
                if [ -z "$CONTAINER_APP_NAME" ] || [ "$APIM_NAME" = "null" ]; then
                  echo "##vso[task.logissue type=error]Failed to retrieve resource names from deployment outputs"
                  exit 1
                fi
                
                echo "##vso[task.setvariable variable=resolvedContainerAppName]$CONTAINER_APP_NAME"
                echo "##vso[task.setvariable variable=resolvedApimName]$APIM_NAME"
                
                echo "Resolved resources:"
                echo "  Container App: $CONTAINER_APP_NAME"
                echo "  APIM: $APIM_NAME"

          - task: AzureCLI@2
            displayName: 'Deploy to Azure Container Apps'
            inputs:
              azureSubscription: 'azure-subscription'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Update Container App with new image
                echo "Updating Container App $(resolvedContainerAppName) with image $(containerRegistry)/$(imageRepository):$(tag)"
                az containerapp update \
                  --name $(resolvedContainerAppName) \
                  --resource-group $(resourceGroupName) \
                  --image $(containerRegistry)/$(imageRepository):$(tag) \
                  --set-env-vars \
                    NODE_ENV=production \
                    PORT=3000 \
                    BUILD_VERSION=$(Build.BuildId)

          - task: AzureCLI@2
            displayName: 'Configure APIM Backend'
            inputs:
              azureSubscription: 'azure-subscription'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                # Get Container App FQDN
                FQDN=$(az containerapp show \
                  --name $(resolvedContainerAppName) \
                  --resource-group $(resourceGroupName) \
                  --query properties.configuration.ingress.fqdn -o tsv)
                
                if [ -z "$FQDN" ]; then
                  echo "##vso[task.logissue type=error]Failed to get Container App FQDN"
                  exit 1
                fi
                
                echo "Container App FQDN: $FQDN"
                
                # Update APIM backend with new Container App URL
                az apim backend update \
                  --resource-group $(resourceGroupName) \
                  --service-name $(resolvedApimName) \
                  --backend-id claim-status-backend \
                  --url "https://$FQDN" || {
                    echo "##vso[task.logissue type=warning]Failed to update APIM backend. This may be expected if backend doesn't exist yet."
                  }